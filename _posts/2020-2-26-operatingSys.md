---
layout: post
title: CPU虚拟化及进程了解
categories: operating
description: 操作系统
keywords: operating
---

## 现代操作系统三要素

### 1. CPU虚拟化

在我们现在的电脑上同一时间往往会有上百个进程同时运行，但是电脑的CPU数量可能只有四个八个，那么每个CPU运行进程量必然是大于一个的。

CPU虚拟化使每个进程都认为自己完全占用整个CPU。CPU虚拟化可以理解为让每个进程都运行一小段时间，那么同一秒内就可以支持多个进程的进行，并且每个进程都是完全占用CPU的。

CPU可以通过分配进程进而实现虚拟化，但是内存只有一个，如果也将内存的内容存到磁盘中的话，每隔一段时间读回来的话这样的效率实际上是非常低的。如果根据进程数将内存进行切割，这样的话，当进程数大的话，每一份进程的内存量就会变得很小，有时候是不足以支持进程的数据量的。**内存虚拟化后期会进行补充。**

### 2. Concurrency并发

可以理解为将一件事分配到多个线程上，例如：a=0，a++，在两个线程上运行一次的话，a会等于2。

### 3. Persistence持久

避免类似RAM断电数据丢失的情况，通过硬盘、磁带、光盘等等实现对数据的长久储存。

## 进程

进程是应用程序的运行实例，进程是应用程序的一次执行。应用程序与进程不一定是一一对应的关系，一个引用程序可能有多个进程来共同实现。

进程是一个程序及其数据在处理机上顺序执行时所发生的活动，进程是具有独立功能的程序在一个数据集合上运行的过程，他是系统进行资源分配和调度的一个独立单位。

针对单一进程来说，程序运行过程会是：程序加载到进程可以有多种策略，比如每次加载一点数据进行执行，也可以将数据全部加载再执行等等(但是这样总会有些问题，内存不够大之类的，**后期会对此进行补充**)，在加载完数据后，我们会先给进程分配一个栈(用于存放返回地址，变量之类的)和堆(用于程序运行过程中动态分配内存)，其次对输入输出进行初始化，最后从主程序开始运行。

### 操作系统管理进程

如果是多进程同时运行，可能会出现死循环的程序，程序运行时长不等，程序间有关联等等情况，那么就需要操作系统来管理进程。

首先要记录进程相关信息：进程控制块(PCB，全面描述进程的所有信息，可视为c语言中的结构体)，然后将进程控制块处理成链表。操作系统直接对该链表进行管理。新进程或者进程结束则类似链表的增删操作。

PCB包含：进程标识符process ID、进程状态、内存、IO

### 进程状态

进程状态包括：运行态、就绪态、阻塞态(I/O请求、申请缓冲区失败等)、创建态、终止态。

挂起态(为了系统观察和分析进程的需要)：

1. 终端用户的需求
2. 进程请求
3. 负荷调节的需要
4. 操作系统的需要

### 进程状态转换

![operating.png](\images\posts\operating.png)

运行->阻塞：

1. 等待I/O结果
2. 资源不可用
3. 等待另一个进程的结果

阻塞->就绪：

1. 进程已经分配到除CPU外的所有必要资源
2. 只要活得CPU就能执行

就绪->运行：

1. CPU空闲
2. 运行状态进行阻塞态
3. 进程运行结束
4. 运行进程主动让出
5. 运行进程被动让出

运行->就绪

1. 程序主动让出

创建->就绪：

创建过程

1. 申请一个空白PCB，并向PCB中填写用于控制和管理进程的信息
2. 为该进程分配运行时所必须的资源
3. 把该进程设为就绪状态，并插入就绪队列中

如果进程所需的资源尚不能得到满足，比如系统尚无足够的内存是进程无法钟乳其中，此时创建工作尚未完成，进程不能被调度运行，于是把此时进程所处的状态称为创建状态。

进程的创建一般在：

1. 系统初始化
2. 正在运行的进程创建了子进程
3. 用户请求创建一个新进程
4. 批处理作业的初始化

运行->终止：

1. 正常退出
2. 出错退出
3. 严重错误
4. 被其他进程杀死

进程终止后：会先等待操作系统进行善后处理，然后清零PCB，并将PCB空间返还系统，最后，进入终止态的进程以后不能再执行，但在操作系统中依然保存一个记录，其中保存状态码和一些计时统计数据，供其他进程收集。

